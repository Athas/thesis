\chapter{Fusion}
\label{chap:fusion}

This chapter will outline the principles behind
\textit{producer-consumer} loop fusion, describe their implementation
in the \LO{} compiler, and discuss possible complications and
restrictions of my handling of loop fusion.

In producer-consumer fusion, the aim is to merge (or \textit{fuse})
two loops, where the output of the first loop -- the producer -- is
used as input to the second -- the consumer.  We currently only fuse
loops that are expressed via SOACs, not the \texttt{do}-notation.  The
reason for this is to simplify analysis, as it can be hard to
determine in which cases arbitrary \texttt{do}-loops can be combined,
whereas it is possible to define simple rules for how and when SOACs
can be fused.

As a simple case, we can fuse the two loops in
\[
\texttt{(map~$f$)~$\circ$~(map~$g$)}
\]
and get
\[
\texttt{map~$(f~\circ~g)$},
\]
thus removing the need to construct an intermediary array for the
result of \texttt{map~$g$}, and in the context of GPGPU, reducely the
likelyhood of global memory accesses.  We will write ``$c_{1}$-$c_{2}$
fusion'' for the case where a fusion is formed with $c_{1}$ as the
producer and $c_{2}$ as the consumer.  Therefore, the previous example
would be ``\texttt{map}-\texttt{map}''-fusion.

\section{Fusion in \LO{}}

The language used to describe the fusion algorithm in this chapter is
\texttt{let}-normalised, internal \LO{}, as described in chapter
\ref{chap:internal}.  We will also assume that all instances of
\texttt{replicate(n,x)} have been rewritten as \texttt{map(fn t (int
  i) => x, iota(n))}.  For clarity, expository examples will use the
external \LO{}.

\begin{figure}
  \begin{center}
    \begin{tabular}{c|c}
      \textbf{Producers} & \textbf{Consumers} \\\hline
      \texttt{map} & \texttt{map} \\\hline
      & \texttt{reduce} \\\hline
      \texttt{scan} & \texttt{scan} \\\hline
      \texttt{filter} & \texttt{filter} \\\hline
      & \texttt{redomap} \\\hline
    \end{tabular}
  \end{center}
  \caption{Producers and consumers in \LO}
  \label{fig:producers-consumers}
\end{figure}

\fref{fig:producers-consumers} lists which \LO{} SOACs are producers,
which are consumers, and which are both.  In particular, note that
even if we have a \texttt{reduce}-expression returning an array, this
does not mean that the \texttt{reduce}-expression is a producer - it
can under no circumstances be fused into another SOAC-expression.  The
reason is that the output of the reduction is only fully known after
the final input array element has been processed.  Consider the
following program:

\begin{colorcode}
let b = reduce(fn [int] ([int] acc, int x) =>
                 map(op + (x), acc),
               iota(10), a) in
map(f, b)
\end{colorcode}

The contents of the array \texttt{b} is not determined until the very
last element of \texttt{a} has been processed, and thus fusion with
the \texttt{map}-expression cannot take place.  While it is possible
to use \texttt{reduce} in a way that could theoretically be fused with
a consumer (for example by using it to simulate \texttt{map}), the
analysis necessary to determine whether a given reduction is fusable
would be quite onerous, and likely not useful in any but contrived
examples, such as the above-mentioned simulation of \texttt{map}.

In this way, \texttt{reduce} differs from \texttt{map}, in which each
element of the output is calculated from one element of the input ---
a classic case of data-parallelism.

Even if we have a producer-consumer-pair, not all such pairs
\textit{can} be fused, and not all are \textit{desirable} to fuse.
For instance, \texttt{filter}-\texttt{map} fusion is not possible,
although \texttt{filter}-\texttt{reduce} is.  The reason is that the
size of the \texttt{map}-output is the same as the size of its input,
yet the size of the output of \texttt{filter} cannot be known in
advance, which preclude an efficient fused form.

The \textit{fusion algebra} in section \ref{sec:fusionalgebra}
describes in detail which producer-consumer pairs can be fused, as
well as the form of the resulting SOAC.

Section \ref{sec:invalidfusion} goes into greater detail on invalid
fusion, and section \ref{sec:whentofuse} covers cases in which fusion
may actually be detrimental to performance.

...

My structural analysis is rooted in the
T$_{1}$-T$_{2}$-transformation~\cite{red_dragon}.\fxnote{Insert more
  about the transformation.}

\section{Invalid fusion}
\label{sec:invalidfusion}

Mumble mumble, something about uniqueness types.\fxnote{Finish this.}

\section{When to fuse}
\label{sec:whentofuse}

Even when fusion is possible, it may not be beneficial, and may be
harmful to overall performance in the following cases.

\begin{description}[style=nextline]
\item[Computation may be duplicated.]

In the program
\begin{colorcode}
let x = map(f, a) in
\{map(g, x), map(h, x)\}
\end{colorcode}
fusing the \texttt{x}-producer into the two consumers will double the
number of calls to the function \texttt{f}, which might be expensive.
The implementation in the \LO{} compiler will currently only fuse if
absolutely no computation is duplicated, although this is likely too
conservative.  Duplicating cheap work, for example functions that use
only primitive operations on scalars, is probably not harmful to
overall performance, although I have not investigated this
fully.\fxnote{Reference someone who has.}

In general, in the context of GPU, the tradeoff between duplicating
computation and increasing communication is not an easy problem to
solve.  Accessing global memory can be more than a hundred times
slower than accessing local (register) memory, hence duplicating
computation is in many cases preferable.

\item[Can reduce memory locality.]

  Consider a simple case of fusing
  \texttt{(map~$f$)~$\circ$~(map~$g$)}.  When $g$ is executed for an
  element of the input array, neighboring elements will be put into
  the cache, making them faster to access.  This exhibits good data
  locality.  In contrast, the composed function $f~\circ~g$ will
  perform more work after accessing a given input element, increasing
  the risk that the input array may be evicted from the cache before
  the next element is to be used.  On GPUs, there is the added risk of
  the kernel function exercising additional register pressure, which
  may reduce hardware occupancy (thus reducing latency hiding) by
  having fewer computational cores active.  In this case, it may be
  better to execute each of the two \texttt{map}s as separate kernels.

  The \LO{} compiler does not currently handle this problem, as it is
  envisioned that a later (and as-of-yet unimplemented) transformation
  will perform \textit{loop distribution} (sometimes called
  \textit{loop fission}).  This step is necessary in any case, as it
  can be used to improve the degree of parallelism, compared to the
  original program.  \fref{fig:loop-distribution} demonstrates a fully
  fused \texttt{map} where the degree of parallelism is can be
  improved by distributing the inner reductions out of the loop.  In
  the original program, the inner map had to wait for the two
  reductions to finish computing \texttt{x} and \texttt{y} before
  executing its inner loop, whereas the distributed program consists
  of three parallel loop nests.
\end{description}

\begin{figure}
\begin{center}
\begin{bcolorcode}
map(fn int ([int] r) =>
      let x = reduce(f, 0, r) in
      let y = reduce(g, 0, r) in
      map(h(x,y), r),
    a)
\end{bcolorcode}

$\Downarrow$

\begin{bcolorcode}
let xs = map(reduce(f,0),a) in
let ys = map(reduce(g,0),a) in
map(fn [int] (\{int,int,[int]\} t) =>
      let \{r,x,y\} = t in
      map(h(x,y), r),
    zip(a,xs,ys))
\end{bcolorcode}
\end{center}
\caption{Loop distribution}
\label{fig:loop-distribution}
\end{figure}

\section{Composition}

\newcommand\mapcompose[7]{ (#1,#2) \underset{\texttt{map}}{\overset{#3}\circ}(#4,#5) \Rightarrow (#6,#7) }
\newcommand\filtercompose[7]{ (#1,#2) \underset{\texttt{filter}}{\overset{#3}\circ}(#4,#5) \Rightarrow (#6,#7) }
\newcommand\foldcompose[7]{ (#1,#2) \underset{\texttt{fold}}{\overset{#3}\circ}(#4,#5) \Rightarrow (#6,#7) }
\newcommand\inputmapping[0]{\mathcal{I}}
\newcommand\arrparams[1]{\textrm{params}(#1)}

To begin our discussion of the precise mechanics of fusion, I will
present the mechanics behind composing the functions involved in a
fusion operation.  For example, consider the trivial example of
\texttt{map}-\texttt{map}-fusion.  In principle, the equation seems
simple enough:
\[
\texttt{map} f \circ \texttt{map} g = \texttt{map} (f \circ g).
\]
However, while the intuition behind the above equation is correct, it
is woefully imprecise.  Fusion in \LO{} is not performed on simple
\texttt{map}s that take input from only one other \texttt{map}, but
complex \texttt{mapT}s that may take input from several sources, where
only some may be fusable.  Hence, a more detailed elaboration is
necessary.

In this section, we will assume that each output of a producer is used
exactly once in every relevant \texttt{redomap}- and
\texttt{map}-consumer.  This assumption can be provided through
trivial rewriting prior to performing function composition, as
illustrated on \fref{fig:single-input-transform}.  We gain the
property that each output of the producer is bound to exactly one
parameter of the consumer's function, making it easier to describe the
relationship between producer and consumer.\footnote{In the actual
  implementation, this transformation is not done.  Instead, the
  composition uses more complicated bookkeeping, but presenting all
  details would obscure the exposition of the central mechanism.}

\begin{figure}
\begin{center}
\begin{bcolorcode}
let \{x, y, z\} = mapT(f, a) in
mapT(fn int (int a, int b, int c) => \(e\), x, y, x)
\end{bcolorcode}

$\Downarrow$

\begin{bcolorcode}
let \{x, y, z\} = mapT(f, a) in
mapT(fn int (int a, int b, int d) =>
       let c = a in \(e\),
     x, y, z)
\end{bcolorcode}
\end{center}
\caption{Single-input transformation}
\label{fig:single-input-transform}
\end{figure}

The presentation will be of the form of \textit{judgements}.  To skip
ahead a bit, I will write the \texttt{map}-composition of two
functions as
\[
\mapcompose{l_{b}}{e_{b_{1}},\ldots,e_{b_{m}}}{o_1,\ldots,o_k}{l_{a}}{e_{a_{1}},\ldots,e_{a_{n}}}{l_{r}}{e_{r_{1}},\ldots,e_{r_{l}}}.
\]
This judgement is said to \textit{hold} if the preconditions specified
for the judgement are upheld.

\subsection{\texttt{map}-\texttt{map} composition}
\label{sec:map-map-composition}

We are given two functions:
\[
l_{a}\equiv\texttt{fn $t_{a_{r}}$ ($p_{a_{1}}$, \ldots, $p_{a_{n}}$) => $e_{a}$}
\]
whose inputs are \texttt{$e_{a_{1}}$,\ldots,$e_{a_{m}}$} and whose
outputs are \texttt{$o_1$,\ldots,$o_k$}; and
\[
l_{b}\equiv\texttt{fn $t_{b_{r}}$ ($p_{b_{1}}$, \ldots, $p_{b_{m}}$) => $e_{b}$},
\]
whose inputs are \texttt{$e_{b_{1}}$,\ldots,$e_{b_{m}}$}.

The goal is to compute a function
\[
l_{r} \equiv \texttt{fn $t_{b_{r}}$ ($p_{r_{1}}$, \ldots, $p_{r_{l}}$)
=> $e_{r}$}
\]
that corresponds to the intuitive notion of the composition $l_{b}
\circ l_{a}$.

For notational convenience, we define the following sets of parameters
of the two functions.
\[
\arrparams{l_{a}} = \{p_{a_{1}}, \ldots, p_{a_{n}}\}
\]
\[
\arrparams{l_{b}} = \{p_{b_{1}}, \ldots, p_{b_{m}}\}
\]

If the inputs of $l_{b}$ are disjoint from the outputs of $l_{a}$,
then we are done, and $l_{r} = l_{b}$.  Otherwise, there is a
non-empty mapping
\[
\inputmapping(o_{i}) = p_{b_{j}} \quad \textrm{when $o_{i} = e_{b_{j}}$}
\]
of outputs of $l_{a}$ to the corresponding parameters of $l_{b}$.  The
parameters (and corresponding inputs) to the desired function $l_{r}$
are the parameters of $l_{b}$, except those in $\inputmapping$,
concatenated with the parameters of $l_{a}$:
\[
\{e_{r_{1}},\ldots,e_{r_{l}}\} = \arrparams{l_{r}} = (\arrparams{l_{b}} \backslash \delta) \oplus \arrparams{l_{a}}
\]
where $\delta$ are the parameters $p_{b_{j}}$ in the range of
$\inputmapping$.

The body of $l_{r}$ is then defined as follows:
\[
e_{r} \equiv \texttt{let \{$\inputmapping(o_{1})$,\ldots,$\inputmapping(o_{k})$\} = $e_{a}$ in $e_{b}$}
\]

I will refer to this entire operation as
\[
\mapcompose{l_{b}}{e_{b_{1}},\ldots,e_{b_{m}}}{o_1,\ldots,o_k}{l_{a}}{e_{a_{1}},\ldots,e_{a_{n}}}{l_{r}}{e_{r_{1}},\ldots,e_{r_{l}}}
\]

\subsection{\texttt{filter}-\texttt{filter} composition}

We are given two functions:
\[
l_{a}\equiv\texttt{fn \{bool\} ($p_{a_{1}}$, \ldots, $p_{a_{n}}$) => $e_{a}$}
\]
which takes as inputs \texttt{$e_{a_{1}}$,\ldots,$i_{e_{n}}$}, and whose
outputs are \texttt{$o_1$,\ldots,$o_k$}; and
\[
l_{b}\equiv\texttt{fn \{bool\} ($p_{b_{1}}$, \ldots, $p_{b_{n}}$) => $e_{b}$},
\]
whose inputs are \texttt{$e_{b_{1}}$,\ldots,$e_{b_{n}}$}.

Every input $e_{b_{i}}$ must correspond to some output $o_{j}$, and
every output $o_{i}$ must correspond to some input $e_{b_{i}}$.  That
is, the producer set of $l_{a}$ is equal to the input set of $l_{b}$.
Or to put it another way, $l_{b}$ takes input from no other source.

The goal is to compute a function
\[
l_{r} \equiv \texttt{fn \{bool\} ($p_{a_{1}}$, \ldots, $p_{a_{n}}$)
=> $e_{r}$}
\]
whose inputs are \texttt{$i_{r_{1}}$,\ldots,$i_{r_{l}}$}, that
corresponds to the intuitive composition of $l_{a} \wedge l_{b}$.
Note that the parameters are the same as for $l_{a}$, which means that
we have to explicitly create a \texttt{let}-binding for the names of
the parameters of $l_{b}$ or they will be free in $e_{b}$.  To this end,
define the mapping
\[
\inputmapping(o_{i}) = p_{b_{j}} \quad \textrm{when $o_{i} = e_{b_{j}}$}.
\]

The body of $l_{r}$ is now definable as
\begin{align*}
e_{r} \equiv\quad&\texttt{let \{$ok$\} = $e_{a}$ in $ok$ \&\&} \\
& \texttt{let \{$\inputmapping(o_{1})$,\ldots,$\inputmapping(o_{k})$\} = \{$p_{a_{i}}$,\ldots,$p_{a_{n}}$\} in $e_{b}$}
\end{align*}
where $ok$ is some fresh variable.

I will refer to this entire operation as
\[
\filtercompose{l_{b}}{e_{b_{1}},\ldots,e_{b_{n}}}{o_{1},\ldots,o_{k}}{l_{a}}{e_{a_{1}},\ldots,e_{a_{n}}}{l_{r}}{e_{a_{1}},\ldots,e_{a_{n}}}
\]

\subsection{\texttt{filter}-\texttt{fold} composition}

We are given two functions:
\[
l_{a}\equiv\texttt{fn \{bool\} ($p_{a_{1}}$, \ldots, $p_{a_{n}}$) => $e_{a}$}
\]
which takes as inputs \texttt{$e_{a_{1}}$,\ldots,$i_{e_{n}}$}, and whose
outputs are \texttt{$o_1$,\ldots,$o_k$}; and
\[
l_{b}\equiv\texttt{fn $t_{b_{r}}$ ($u_{b_{1}}$, \ldots, $u_{b_{m}}$, $p_{b_{1}}$, \ldots, $p_{b_{n}}$) => $e_{b}$},
\]
whose inputs are \texttt{$e_{b_{1}}$,\ldots,$e_{b_{n}}$} and every
input $e_{b_{i}}$ corresponds to some output $o_{j}$, and every output
$o_{i}$ corresponds to some input $e_{b_{i}}$.  That is, the producer
set of $l_{a}$ is equal to the input set of $l_{b}$.  Or to put it
another way, $l_{b}$ takes input from no other source.  The $u_{b}$s
are accumulator parameters that do not correspond to an array input.

The goal is to compute a function
\[
l_{r} \equiv \texttt{fn $t_{b_{r}}$ ($p_{r_{1}}$, \ldots, $p_{r_{l}}$)
=> $e_{r}$}.
\]

Note that the parameters are the same as for $l_{a}$, which means that
we have to explicitly create a \texttt{let}-binding for the names of
the parameters of $l_{b}$ before $e_{b}$ makes sense.  To this end,
define the mapping
\[
\inputmapping(o_{i}) = p_{b_{j}} \quad \textrm{when $o_{i} = e_{b_{j}}$}.
\]

The body of $l_{r}$ is now definable as
\begin{align*}
e_{r} \equiv\quad&\texttt{let \{$ok$\} = $e_{a}$ in if $ok$} \\
& \texttt{then let \{$\inputmapping(o_{1})$,\ldots,$\inputmapping(o_{k})$\} = \{$p_{a_{i}}$,\ldots,$p_{a_{n}}$\} in $e_{b}$} \\
& \texttt{else \{$u_{b_{1}}$, \ldots, $u_{b_{m}}$\}}
\end{align*}
where $ok$ is some fresh variable.

I will refer to this entire operation as
\[
\foldcompose{l_{b}}{e_{b_{1}},\ldots,e_{b_{n}}}{o_{1},\ldots,o_{k}}{l_{a}}{e_{a_{1}},\ldots,e_{a_{n}}}{l_{r}}{e_{a_{1}},\ldots,e_{a_{n}}}
\]

\section{Fusion rules}

\newcommand\fusesto[4]{\bfrac{#2\overset{#1}{\leadsto}#3}{\Rightarrow #4}}

With function composition defined, we can define fusion rules for
SOACs.  I present fusion as a judgement
\[
\fusesto{os}{producer}{consumer}{result}.
\]
This means that $producer$, which produces outputs $os$, can be fused
with $consumer$, yielding $result$ as the combined SOAC.  Valid
judgements of this form are given by the following inference rules,
which should mostly be intuitive.

\begin{align*}
  \nfrac{
    \mapcompose{l_{b}}{es_{b}}{os}{l_{a}}{es_{a}}{l_{r}}{es_{r}}
  }{
    \fusesto
    {\texttt{$os$}}
    {\texttt{mapT($l_{a}$,$es_a$)}}
    {\texttt{mapT($l_{b}$,$es_b$)}}
    {\texttt{mapT($l_{r}$,$es_r$)}}
  }
  \tagsc{Fuse-Map-Map}
\end{align*}

\begin{align*}
  \nfrac{
    \mapcompose
    {\texttt{fn $t_{b_{r}}$ ($ps_{b}$) => $e_{b}$}}
    {es_{b}}
    {os}
    {l_{a}}
    {es_{a}}
    {\texttt{fn $t_{b_{r}}$ ($ps_{r}$) => $e_{r}$}}
    {es_{r}}
  }{
    \fusesto
    {\texttt{$os$}}
    {\texttt{mapT($l_{a}$,$es_{a}$)}}
    {\texttt{redomapT($\oplus$,\texttt{fn $t_b$ ($us_{b}$, $ps_{b}$) => $e_{b}$},\{$vs$\},$es_{b}$)}}
    {\texttt{redomapT($\oplus$,\texttt{fn $t_b$ ($us_{b}$, $ps_{r}$) => $e_{r}$},\{$vs$\},$es_{r}$)}}
  }
  \tagsc{Fuse-Map-Redomap}
\end{align*}

\begin{align*}
  \nfrac{
    \foldcompose
    {\texttt{fn $t_{b_{r}}$ ($ps_{b}$) => $e_{b}$}}
    {es_{b}}
    {os}
    {l_{a}}
    {es_{a}}
    {\texttt{fn $t_{b_{r}}$ ($ps_{r}$) => $e_{r}$}}
    {es_{a}}
  }{
    \fusesto
    {\texttt{$os$}}
    {\texttt{filterT($l_{a}$,$es_{a}$)}}
    {\texttt{redomapT($\oplus$,\texttt{fn $t_b$ ($us_{b}$, $ps_{b}$) => $e_{b}$},\{$vs$\},$es_{b}$)}}
    {\texttt{redomapT($\oplus$,\texttt{fn $t_b$ ($us_{b}$, $ps_{r}$) => $e_{r}$},\{$vs$\},$es_{a}$)}}
  }
  \tagsc{Fuse-Filter-Redomap}
\end{align*}

Fusing \texttt{map}-\texttt{reduce} and
\texttt{filter}-\texttt{reduce} is usually done by first rewriting
\texttt{reduce} to \texttt{redomap}, although when the producer-output
and consumer-input match exactly, \texttt{filter}-\texttt{reduce} can
fuse to \texttt{reduce}.

\begin{align*}
  \nfrac{
    \fusesto
    {\texttt{\{$os$\}}}
    {\texttt{mapT($l_{a}$,$es_a$)}}
    {\texttt{redomapT($l_{b}$,$l_{b}$,\{$us$\},$es_b$)}}
    {\texttt{redomapT($\oplus$,$l_{r}$,\{$us$\},$es_r$)}}
  }{
    \fusesto
    {\texttt{$os$}}
    {\texttt{mapT($l_{a}$,$es_a$)}}
    {\texttt{reduceT($l_{b}$,\{$us$\},$es_b$)}}
    {\texttt{redomapT($\oplus$,$l_{r}$,\{$us$\},$es_r$)}}
  }
  \tagsc{Fuse-Map-Reduce}
\end{align*}

\begin{align*}
  \nfrac{
    \fusesto
    {\texttt{\{$os$\}}}
    {\texttt{filterT($l_{a}$,$es_a$)}}
    {\texttt{redomapT($l_{b}$,$l_{b}$,\{$us$\},$es_b$)}}
    {\texttt{redomapT($l_{b}$,$l_{r}$,\{$us$\},$es_a$)}}
    \quad
    os:es_{b}\ ::\ us:us'
  }{
    \fusesto
    {\texttt{$os$}}
    {\texttt{filterT($l_{a}$,$es_a$)}}
    {\texttt{reduceT($l_{b}$,\{$us$\},$es_b$)}}
    {\texttt{reduceT($l_{r}$,\{$us'$\},$es_a$)}}
  } (\textrm{types of $os = $ types of $es_{b}$})
  \tagsc{Fuse-Filter-Reduce-1}
\end{align*}
\fxnote{Define $::$}

Note that \textsc{Fuse-Filter-Reduce-1} has a side condition that
implies that the types of $es_{a}$ are equal to the types of $es_{b}$.
This permits us to keep the result as a \texttt{reduceT} rather than a
\texttt{redomapT}.

\begin{align*}
  \nfrac{
    \fusesto
    {\texttt{\{$os$\}}}
    {\texttt{filterT($l_{a}$,$es_a$)}}
    {\texttt{redomapT($l_{b}$,$l_{b}$,\{$us$\},$es_b$)}}
    {\texttt{redomapT($\oplus$,$l_{r}$,\{$us$\},$es_r$)}}
  }{
    \fusesto
    {\texttt{$os$}}
    {\texttt{filterT($l_{a}$,$es_a$)}}
    {\texttt{reduceT($l_{b}$,\{$us$\},$es_b$)}}
    {\texttt{redomapT($\oplus$,$l_{r}$,\{$us$\},$es_r$)}}
  }
  \tagsc{Fuse-Filter-Reduce-2}
\end{align*}

\section{Dataflow}

\newcommand{\unfusable}[0]{\textsc{unfusable}}
\newcommand{\inputs}[0]{\textsc{arrInputs}}
\newcommand{\soacs}[0]{\textsc{SOACs}}
\newcommand{\patNames}[1]{\textsc{patNames}(#1)}
\newcommand{\childExps}[1]{\textsc{childExps}(#1)}
\newcommand{\parentExp}[1]{\textsc{parentExp}(#1)}

We will track the following pieces of information.\fxnote{All of this can be done in one pass - explain how and why.}

\begin{description}
\item[$\soacs : Exp \rightarrow Label \times Pat \times Exp$.] The set
  of all SOAC expressions in an expression, modelled as a mapping from
  a (unique) identifier to a pair of a SOAC expression and its output
  pattern.  We shall say $\soacs(e)$ to refer to this mapping, and
  $\soacs(e)[l]$ to refer to the SOAC with label $l$.  For example,
  \begin{align*}
  & \soacs(\texttt{let \{$a$,$b$,$c$\} = mapT($f$,$x$,$y$,$z$) in \{$a$,$b$,$c$\}}) =\\
  & \quad \{ (\ell, \texttt{\{$a$,$b$,$c$\}},\texttt{mapT($f$,$x$,$y$,$z$)}) \},
  \end{align*}
  where $\ell$ is a fresh label.  After the $\soacs$ set has been
  computed, we can use $\soacs(e_{b})$, where $e_{b}$ is the body of a
  function to refer to the set of all SOACS in that function.  Since
  the fusion transformation is strictly intraprocedural, this is
  sufficient for our needs.

\item[$\unfusable : Exp \rightarrow Names$.] The \textit{unfusable set}, which
  is key to preventing unwanted fusion, as it indicates which SOACs
  should never be fused.  The unfusable set prevents both undesired
  and invalid fusion, as outlined in sections \ref{sec:whentofuse} and
  \ref{sec:invalidfusion} respectively.  Given an \LO{} expression
  $e$, we shall say $\unfusable(e)$ to refer to the unfusable set
  produced by $e$.  For example:
  \begin{align*}
  \unfusable(&\texttt{let x = mapT(f,a) in}\\
  &\texttt{let y = mapT(g,a) in \{x,y\}}) = \{a\},
  \end{align*}
  because $a$ is used twice, and hence fusing its producer into
  \texttt{f} and \texttt{g} would cause work duplication.  (To
  simplify the example, I have ignored $f$ and $g$ when computing the
  unfusable set, although as we shall see below, this is not the case
  in practice.)

\item[$\inputs : Exp \rightarrow Name \rightarrow Labels$.] A mapping from arrays to a set of the SOACs that use the array
  as input.  This is modelled as a set of pairs, each pair consisting
  of an array name and a SOAC name.  We shall refer to the mapping
  generated by a given expression $e$ as $\inputs(e)$.  For example,
  \[
  \inputs(\texttt{mapT($f$, $x$, $y$, $z$)}) = \{ (x, \{\ell\}), (y, \{\ell\}), (z, \{\ell\}) \},
  \]
  where $\ell$ is the label of the \texttt{mapT}-SOAC.

  We define an associative and commutative operation $\sqcup$ to
  combine input mappings by taking the union of values of
  corresponding keys, as follows.
  \begin{align*}
  &\{(v_{1},s_{1}),\ldots,(v_{n},s_{n})\} \sqcup \{(v_{n+1},s_{n+1}),\ldots,(v_{n+m},s_{n+m})\} =\\
  &\quad \{(v_{i}, \bigcup_{(v_{i},s_{i}),n+m \leq i \leq n+m} s_{i})\},
  \end{align*}

  Intuitively, $x \sqcup y$ is a mapping that contains the union of
  the keys in $x$ and $y$, with the value for a key being the union of
  the values for that key in $x$ and $y$ (or just an untouched value,
  if the key was only present in one of the mappings).

  Similarly, we define $\sqcap$ to define a similar mapping, except
  taking the intersection of values.
\begin{align*}
  &\{(v_{1},s_{1}),\ldots,(v_{n},s_{n})\} \sqcap \{(v_{n+1},s_{n+1}),\ldots,(v_{n+m},s_{n+m})\} =\\
  &\quad \{(v_{i}, \bigcap_{(v_{i},s_{i}),n+m \leq i \leq n+m} s_{i})\},
  \end{align*}
\end{description}

If more specific rules are not given, the data flows default to the
following.

\begin{align*}
  \unfusable(e) &= \bigcup_{e'\in\childExps{e}} \unfusable(e') \\
  \\
  \inputs(e) &= \bigsqcup_{e'\in\childExps{e}} e'\\
  \\
  \soacs(e) &= \bigcup_{e'\in\childExps{e}} \soacs(e')
\end{align*}
Where $\childExps{e}$ are the \textit{immediate} children of $e$, e.g.
\[
\childExps{\texttt{if p(x) then t(y) else f(z)}} = \{\texttt{p(x)}, \texttt{t(y)}, \texttt{f(z)}\}.
\]

Now for specific rules, based on the shape of the given expression.

\begin{description}[style=nextline]
\item[Case $e \equiv v$]

  This rule is only applied when $v$ is not an array input to a SOAC.
  This implies that the producer of $v$ cannot be fused, as its output
  $v$ is used here.
\begin{align*}
  & \unfusable(e) = \{v\} \\
\end{align*}

\item[Case $e \equiv \texttt{$v$[$e_{1}$, \ldots, $e_{n}$]}$]

  If an element is retrieved from an array through indexing, we have
  no choice but to manifest that array, thus forcing us to avoid
  fusion due to our principle of avoiding duplication of computation.
  In many cases, for example if the array $v$ is the result of a
  \texttt{map} operation, it might be beneficial to replace the index
  operation by an inlined copy of the \texttt{map} function, and let
  the original \texttt{map} be fused.  Duplicating computation of a
  single element is likely acceptable, but not done by the current
  implementation. \fxnote{We actually do this in limited cases.}
  \begin{align*}
  & \unfusable(e) = \{v\} \cup \bigcup_{1\leq i \leq n}\unfusable(e_{i}) \\
\end{align*}

\item[Case $e \equiv \texttt{if $e_{c}$ then $e_{t}$ else $e_{f}$}$]

  The \unfusable{} of a conditional consists of whatever is in the
  \unfusable{} sets of its branches, plus any SOAC outputs that may be
  used multiple times.  Note that an output can be used in both the
  true and the false branch, and it will still only have been
  considered to be used once.

\begin{align*}
  & \inputs(e) =\\
  & \quad \{ (v,s')\ |\ (v,s) \in \inputs(e_{t}) \cup \inputs(e_{f}) \}\\
  & \quad\quad \text{Where $s'$ is the set of all SOAC consumers of $v$ in both $e_{t}$ and $e_{f}$.} \\
  \\
  & \unfusable(e) =\\
  & \quad \unfusable(e_{c}) \cup \unfusable(e_{t}) \cup \unfusable(e_{f})\\
  & \quad \cup (\inputs(e_{c}) \sqcap \inputs(e_{t}))\\
  & \quad \cup (\inputs(e_{c}) \sqcap \inputs(e_{f}))\\
\end{align*}

The reason for these rules can be illustrated by the following
examples.  In \fref{fig:fuse-across-if-ok}, it is clear that fusing
computation of \texttt{b} with both \texttt{map(g,b)} and
\texttt{map(g,b)} will not cause duplicated computation, as the two
consumers are on separate control-flow paths.  On the other hand, if
even one branch contains multiple uses, as in
\fref{fig:fuse-across-if-bad}, we should not fuse.  Additionally, if
both the conditional expression and a branch consumes the same array,
as on \fref{fig:fuse-across-if-bad-condition}, then we should also not
fuse.

\begin{figure}
\begin{center}
\begin{bcolorcode}
let b = map(f, a) in
if p(x) then map(g,b)
        else map(h,b)
\end{bcolorcode}
\end{center}
\caption{Fusion into branches acceptable}
\label{fig:fuse-across-if-ok}
\end{figure}

\begin{figure}
\begin{center}
\begin{bcolorcode}
let b = map(f, a) in
if p(x) then concat(map(g,b),map(v,b))
        else map(h,b)
\end{bcolorcode}
\end{center}
\caption{Duplicating computation in one branch}
\label{fig:fuse-across-if-bad}
\end{figure}

\begin{figure}
\begin{center}
\begin{bcolorcode}
let b = map(f, a) in
if p(map(v,b)) then map(g,b)
               else map(h,b)
\end{bcolorcode}
\end{center}
\caption{Duplicating computation in conditional}
\label{fig:fuse-across-if-bad-condition}
\end{figure}

\item[Case $e \equiv \texttt{let \{$vs$\} = $soac$ in $e_{b}$}$]

  The big question here is whether $soac$ can be fused as producer
  with something in $\soacs(e_{b})$.  In the following, $\ell_{p}$ is
  a fresh name.  Let
  \[
  \zeta = \bigcup_{v \in vs} \inputs(e_{b},v)
  \]
  be the set of the labels of all SOACs that take our output as input.
  Additionally, let $e_{f}$ be the body of the function of $soac$.  In
  case $soac$ is \texttt{redomapT}, the second function (the inner
  fold) is used, as this is the one that is actually composed.

  For all $\ell_{c} \in \zeta$, we find the corresponding triple
  $(\ell_{c},vs_{c},soac_{c})$ in $\soacs(e_{b})$.  We can check
  whether fusion is possible by determining whether the following
  judgement is derivable.

\[
   \fusesto
    {vs}
    {soac}
    {soac_{c}}
    {soac_{c_{r}}}
\]

If so, we can fuse $soac$ with $soac_{c}$ and get $soac_{c_{r}}$.  We
only perform fusion if we can fuse with \textit{all} consumers in
$\zeta$, as we might otherwise duplicate computation.

Additionally, we must also check whether any of $vs$ are in the
unfusable set.  Thus, if the intersection
\[
vs \cap \unfusable(e_{b})
\]
is non-empty, we cannot fuse at all.

\begin{description}
\item[Can fuse:]

  In this case, we are fusing with several SOACs $soac_{c}$, each with
  a corresponding label $\ell_{c}$, and fused as $soac_{c_{r}}$.

\begin{align*}
  & \soacs(e) =\\
  & \quad (\soacs(e_{b}) \backslash \zeta)\\
  & \quad \cup \soacs(e_{f})\\
  & \quad \cup \{ (\ell_{c}, (vs, soac_{r})) | \textrm{for each $soac_{c_{r}}$} \}\\
  \\
  & \inputs(e) =\\
  & \quad (\textrm{$\inputs(e_{b})$ with all mappings to each $\ell_{c}$ removed}) \\
  & \quad \sqcup \{ (v,\ell_{c}) |\ \textrm{for all array inputs $v$ in each $soac_{c_{r}}$} \}
\end{align*}

\item[Cannot fuse:]

  If we \textit{cannot} fuse with all consumers in $\zeta$, or one of
  the outputs of $soac$ is in the unfusable set, then we cannot fuse
  with $soac$ as a producer, and we must add it by itself.  It may be
  fused as the consumer at some later stage of the algorithm, however.

\begin{align*}
  & \unfusable(e) =\\
  & \quad \unfusable(e_{b})\\
  & \quad \cup \{ v\ |\ (v,s) \in \inputs(e_{f}) \} \\
  & \quad \cup \{ v\ |\ \textrm{$v$ is used as input here but is also in $\inputs(e_{b})$} \}\\
  \\
  & \inputs(e) =\\
  & \quad \inputs(e_{b})\\
  & \quad \sqcup \inputs(e_{f})\\
  & \quad \sqcup \{(e_{1},\{\ell_{p}\}), \ldots, (e_{n},\{\ell_{p}\})\}\\
  \\
  & \soacs(e) = \soacs(e_{b}) \cup \{(\ell_{p}, (vs, soac))\} \\
  &
\end{align*}
\end{description}

\item[Case $e \equiv \texttt{let $v_{1}$ = $v_{2}$ with [$e_{1}$,\ldots,$e_{n}$] <- $e_{v}$ in $e_b$}$]

Record the in-place modification of $v_{2}$. \fxnote{Not sure how to model this yet.}

\item[Case $e \equiv \texttt{loop ($p$ = $e_{1}$) = for $v$ < $e_{2}$ do $e_{3}$ in $e_{4}$}$]

  For loops, we add any arrays used as SOAC inputs in the loop body to
  the unfusable set, as fusing into the loop would duplicate
  computation, by re-evaluating the function in the consumer for every
  iteration of the loop -- see \fref{fig:cannot-fuse-loop} for an
  example of this.  This is similar to how we ban fusing into
  SOAC-functions.
\begin{align*}
  & \unfusable(e) =\\
  & \quad \unfusable(e_{1}) \cup \unfusable(e_{2}) \cup \unfusable(e_{3}) \cup \unfusable(e_{4}) \\
  & \quad \cup \{ v\ |\ (v,s) \in \inputs(e_{3}) \}
\end{align*}

\begin{figure}
\begin{center}
\begin{bcolorcode}
let b = \emphh{map(f, a)} in
loop (v) = for i < n do
             let c = \emp{map(g, b)} in
             h(v,c) in
...
\end{bcolorcode}
\end{center}
\caption{Fusing the \emphh{producer} into the \emp{consumer} in the loop body would duplicate computation}
\label{fig:cannot-fuse-loop}
\end{figure}

\end{description}

\section{Fusion algebra}
\label{sec:fusionalgebra}

\fxnote{This is horrible.  Fix me.}

\begin{figure}[bt]
\begin{colorcode}
// \emp{replicate can be fused}
// \emp{without restrictions}
let x = replicate(N,a)in 
let y = mapT(f, x, b) in
let z = mapT(g, x, c) in 
let x[i] = ...
    \emphh{\mymath{\equiv}}
let x = replicate(N, a) in 
let y = mapT( fn \mymath{\beta\myindx{1}} (\mymath{\alpha\myindx{1}} b\mymath{\myindx{i}}) 
              => f(a,b\mymath{\myindx{i}}), b)
let z = mapT( fn \mymath{\beta\myindx{2}} (\mymath{\alpha\myindx{2}} c\mymath{\myindx{i}}) 
              => g(a,c\mymath{\myindx{i}}), c)
in let x[i] = ...   


//\emp{mapT o mapT \mymath{\Rightarrow} mapT}  
let (x1, x2) = mapT(f, a1)
in  mapT(g, x1, y)   
    \emphh{\mymath{\equiv}}
mapT(fn \mymath{\beta} (\mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} y\mymath{\myindx{i}})
  =>let (x1\mymath{\myindx{i}}, x2\mymath{\myindx{i}}) = f(a1\mymath{\myindx{i}})
    in  g(x1\mymath{\myindx{i}}, y\mymath{\myindx{i}})
, a1, y )


//\emp{reduceT o mapT\mymath{\Rightarrow}redomapT}
let (x1, x2) = mapT(f, a1)
in  reduceT(\mymath{\oplus},e\mymath{\myindx{1}},e\mymath{\myindx{2}}, x1,y)   
    \emphh{\mymath{\equiv}}
redomapT(\mymath{\oplus}
, fn (\mymath{\beta\myindx{1}},\mymath{\beta\myindx{2}}) ( \mymath{\beta\myindx{1}} e\mymath{\myindx{1}}, \mymath{\beta\myindx{2}} e\mymath{\myindx{2}}
             , \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}},\mymath{\alpha\myindx{2}} y\mymath{\myindx{i}})
   => let (x1\mymath{\myindx{i}}, x2\mymath{\myindx{i}}) = f(a1\mymath{\myindx{i}})
      in  \mymath{\oplus}(e\mymath{\myindx{1}},e\mymath{\myindx{2}},x1\mymath{\myindx{i}},y\mymath{\myindx{i}})
, (e\mymath{\myindx{1}}, e\mymath{\myindx{2}}), a1, y )


//\emp{redomapT o mapT\mymath{\Rightarrow}redomapT}
let (x1, x2) = mapT(f, a1)
in  redomapT(\mymath{\oplus}, g, e, x1, y)
    \emphh{\mymath{\equiv}}
redomapT(\mymath{\oplus}
, fn \mymath{\beta} (\mymath{\beta} e, \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} y\mymath{\myindx{i}})
   => let (x1\mymath{\myindx{i}}, x2\mymath{\myindx{i}}) = f(a1\mymath{\myindx{i}})
      in  g(e, x1\mymath{\myindx{i}}, y\mymath{\myindx{i}})
, e, a1, y )

//\emp{filterT o filterT\mymath{\Rightarrow}filterT}
//\emp{{\em{}IFF} consumer's input set}
//\emp{  \mymath{\subseteq} producer's output set}
let (x1,x2)=filterT(c\mymath{\myindx{1}},a1,a2)
in  let y = filterT(c\mymath{\myindx{2}}, x1) ..
    \emphh{\mymath{\equiv}}
let (y, dead) = filterT(
  fn bool (\mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}},\mymath{\alpha\myindx{2}} a2\mymath{\myindx{i}})=> 
      if   c\mymath{\myindx{1}}(a1\mymath{\myindx{i}}, a2\mymath{\myindx{i}}) 
      then c\mymath{\myindx{2}}(a1\mymath{\myindx{i}}) 
      else false 
, a1, a2 ) ..

//\emp{reduceT o filterT\mymath{\Rightarrow}redomapT}
//\emp{{\em{}IFF} consumer's input list}
//\emp{  \mymath{\equiv} producer's output list}
let x = filterT(c, a)
in  reduceT(\mymath{\oplus}, e, x)
    \emphh{\mymath{\equiv}}
reduceT(fn \mymath{\beta} (\mymath{\beta} e, \mymath{\beta} a\mymath{\myindx{i}}) =>
  if c(a\mymath{\myindx{i}}) then \mymath{\oplus}(e,a\mymath{\myindx{i}}) else e
, e, a )

//\emp{reduceT o filterT\mymath{\Rightarrow}redomapT}
//\emp{{\em{}IFF} consumer's input set}
//\emp{  \mymath{\subseteq} producer's output set}
let (x1,x2)=filterT(c, a1, a2)
in  reduceT(\mymath{\oplus}, e, x1)
    \emphh{\mymath{\equiv}}
redomapT(\mymath{\oplus}
, fn \mymath{\beta} (\mymath{\beta} e, \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} a2\mymath{\myindx{i}})
   => if c(a1\mymath{\myindx{i}}, a2\mymath{\myindx{i}})
      then \mymath{\oplus}(e, a1\mymath{\myindx{i}}) else e
, e, a1, a2 )

//\emp{redomapT o filterT\mymath{\Rightarrow}redomapT}
//\emp{{\em{}IFF} consumer's input set}
//\emp{  \mymath{\subseteq} producer's output set}
let (x1,x2)=filterT(c, a1, a2)
in  redomapT(\mymath{\oplus}, g, e, x1)
    \emphh{\mymath{\equiv}}
redomapT(\mymath{\oplus}
, fn \mymath{\beta} (\mymath{\beta} e, \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} a2\mymath{\myindx{i}})
   => if c(a1\mymath{\myindx{i}}, a2\mymath{\myindx{i}})
      then g(e, a1\mymath{\myindx{i}}) else e
, e, a1, a2 )
\end{colorcode}
\caption{Compositional Algebra For Fusion}
\label{fig:fusion-algebra}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis.tex"
%%% End: 
