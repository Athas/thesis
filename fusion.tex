\chapter{Fusion}

This chapter will outline the principles behind
\textit{producer-consumer} loop fusion, describe their implementation
in the \LO{} compiler, and discuss possible complications and
restrictions of my handling of loop fusion.

In producer-consumer fusion, the aim is to merge (or \textit{fuse})
two loops, where the output of the first loop -- the producer -- is
used as input to the second -- the consumer.  I currently only fuse
loops that are expressed via SOACs, not the \texttt{do}-notation.  The
reason for this is to simplify analysis, as it can be hard to
determine in which cases arbitrary \texttt{do}-loops can be combined,
whereas it is possible to define simple rules for how and when SOACs
can be fused.

As a simple case, we can fuse the two loops in
\texttt{(map~$f$)~$\circ$~(map~$g$)} and get
\texttt{map~$(f~\circ~g)$}, thus removing the need to construct an
intermediary array for the result of \texttt{map~$g$}.  I will write
``$c_{1}$-$c_{2}$ fusion'' for the case where a fusion is formed with
$c_{1}$ as the producer and $c_{2}$ as the consumer.  Therefore, the
previous example would be ``\texttt{map}-\texttt{map}''-fusion.

Figure \ref{fig:producers-consumers} lists which \LO{} SOACs are
producers, and which are consumers\footnote{For this chapter, we will
  treat \texttt{replicate} as a SOAC.}  In particular, note that even
if we have a \texttt{reduce} expression returning an array, this does
not mean that we can fuse the reduction with whatever consumes that
array.  Furthermore, not all producer-consumer pairs \textit{can} be
fused, and not all are \textit{desirable} to fuse.  For example,
\texttt{filter}-\texttt{map} fusion is not possible, although
\texttt{filter}-\texttt{reduce} is.  The \textit{fusion
  algebra}\fxnote{Link here} describes which producer-consumer pairs
can be fused, as well as the form of the resulting SOAC.

\begin{figure}
  \begin{center}
    \begin{tabular}{c|c}
      \textbf{Producers} & \textbf{Consumers} \\\hline
      \texttt{map} & \texttt{map} \\\hline
      & \texttt{reduce} \\\hline
      \texttt{scan} & \texttt{scan} \\\hline
      \texttt{filter} & \texttt{filter} \\\hline
      & \texttt{redomap} \\\hline
      \texttt{replicate} & \\\hline
    \end{tabular}
  \end{center}
  \caption{Producers and consumers in \LO}
  \label{fig:producers-consumers}
\end{figure}

...

My structural analysis is rooted in the
T$_{1}$-T$_{2}$-transformation~\cite{red_dragon}.\fxnote{Insert more
  about the transformation.}

\section{When to fuse}

Fusion is not always beneficial, and may be harmful to overall
performance in the following cases.

\begin{description}[style=nextline]
\item[Computation may be duplicated.]

In the program
\begin{colorcode}
let x = map(f, a) in
\{map(g, x), map(h, x)\}
\end{colorcode}
fusing the \texttt{x}-producer into the two consumers will double the
number of calls to the function \texttt{f}, which might be expensive.
The implementation in the \LO{} will currently only fuse if absolutely
no computation is duplicated, although this is likely too
conservative.  Duplicating cheap work, for example functions that use
only primitive operations on scalars, is probably not harmful to
overall performance, although this has not been fully
investigated.\fxnote{Reference someone who has}

\item[Can reduce memory locality.]

  Consider a simple case of fusing
  \texttt{(map~$f$)~$\circ$~(map~$g$)}.  When $g$ is executed for an
  element of the input array, neighboring elements will be put into
  the cache, making them faster to access.  This exhibits good data
  locality.  In contrast, the composed function $f~\circ~g$ will
  perform more work after accessing a given input element, increasing
  the risk that the input array may be evicted from the cache before
  the next element is to be used.  On GPUs, there is the added risk of
  the kernel function becoming so large in terms of register usage,
  that not as many can be executed in parallel.  In this case, it may
  be better to execute each of the two \texttt{map}s as separate
  kernels.

  The \LO{} compiler does not currently worry about this problem, as
  it is envisioned that a later (and as-of-yet unimplemented)
  transformation will perform \textit{loop distribution} (sometimes
  called \textit{loop fission}).  This step is necessary anyway, as it
  can be used to improve the degree parallelism, compared to the
  original program.
\end{description}


\section{Fusion algebra}

\begin{figure}[bt]
\begin{colorcode}
// \emp{replicate can be fused}
// \emp{without restrictions}
let x = replicate(N,a)in 
let y = map2(f, x, b) in
let z = map2(g, x, c) in 
let x[i] = ...
    \emphh{\mymath{\equiv}}
let x = replicate(N, a) in 
let y = map2( fn \mymath{\beta\myindx{1}} (\mymath{\alpha\myindx{1}} b\mymath{\myindx{i}}) 
              => f(a,b\mymath{\myindx{i}}), b)
let z = map2( fn \mymath{\beta\myindx{2}} (\mymath{\alpha\myindx{2}} c\mymath{\myindx{i}}) 
              => g(a,c\mymath{\myindx{i}}), c)
in let x[i] = ...   


//\emp{map2 o map2 \mymath{\Rightarrow} map2}  
let (x1, x2) = map2(f, a1)
in  map2(g, x1, y)   
    \emphh{\mymath{\equiv}}
map2(fn \mymath{\beta} (\mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} y\mymath{\myindx{i}})
  =>let (x1\mymath{\myindx{i}}, x2\mymath{\myindx{i}}) = f(a1\mymath{\myindx{i}})
    in  g(x1\mymath{\myindx{i}}, y\mymath{\myindx{i}})
, a1, y )


//\emp{reduce2 o map2\mymath{\Rightarrow}redomap2}
let (x1, x2) = map2(f, a1)
in  reduce2(\mymath{\oplus},e\mymath{\myindx{1}},e\mymath{\myindx{2}}, x1,y)   
    \emphh{\mymath{\equiv}}
redomap2(\mymath{\oplus}
, fn (\mymath{\beta\myindx{1}},\mymath{\beta\myindx{2}}) ( \mymath{\beta\myindx{1}} e\mymath{\myindx{1}}, \mymath{\beta\myindx{2}} e\mymath{\myindx{2}}
             , \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}},\mymath{\alpha\myindx{2}} y\mymath{\myindx{i}})
   => let (x1\mymath{\myindx{i}}, x2\mymath{\myindx{i}}) = f(a1\mymath{\myindx{i}})
      in  \mymath{\oplus}(e\mymath{\myindx{1}},e\mymath{\myindx{2}},x1\mymath{\myindx{i}},y\mymath{\myindx{i}})
, (e\mymath{\myindx{1}}, e\mymath{\myindx{2}}), a1, y )


//\emp{redomap2 o map2\mymath{\Rightarrow}redomap2}
let (x1, x2) = map2(f, a1)
in  redomap2(\mymath{\oplus}, g, e, x1, y)
    \emphh{\mymath{\equiv}}
redomap2(\mymath{\oplus}
, fn \mymath{\beta} (\mymath{\beta} e, \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} y\mymath{\myindx{i}})
   => let (x1\mymath{\myindx{i}}, x2\mymath{\myindx{i}}) = f(a1\mymath{\myindx{i}})
      in  g(e, x1\mymath{\myindx{i}}, y\mymath{\myindx{i}})
, e, a1, y )

//\emp{filter2 o filter2\mymath{\Rightarrow}filter2}
//\emp{{\em{}IFF} consumer's input set}
//\emp{  \mymath{\subseteq} producer's output set}
let (x1,x2)=filter2(c\mymath{\myindx{1}},a1,a2)
in  let y = filter2(c\mymath{\myindx{2}}, x1) ..
    \emphh{\mymath{\equiv}}
let (y, dead) = filter2(
  fn bool (\mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}},\mymath{\alpha\myindx{2}} a2\mymath{\myindx{i}})=> 
      if   c\mymath{\myindx{1}}(a1\mymath{\myindx{i}}, a2\mymath{\myindx{i}}) 
      then c\mymath{\myindx{2}}(a1\mymath{\myindx{i}}) 
      else false 
, a1, a2 ) ..

//\emp{reduce2 o filter2\mymath{\Rightarrow}redomap2}
//\emp{{\em{}IFF} consumer's input list}
//\emp{  \mymath{\equiv} producer's output list}
let x = filter2(c, a)
in  reduce2(\mymath{\oplus}, e, x)
    \emphh{\mymath{\equiv}}
reduce2(fn \mymath{\beta} (\mymath{\beta} e, \mymath{\beta} a\mymath{\myindx{i}}) =>
  if c(a\mymath{\myindx{i}}) then \mymath{\oplus}(e,a\mymath{\myindx{i}}) else e
, e, a )

//\emp{reduce2 o filter2\mymath{\Rightarrow}redomap2}
//\emp{{\em{}IFF} consumer's input set}
//\emp{  \mymath{\subseteq} producer's output set}
let (x1,x2)=filter2(c, a1, a2)
in  reduce2(\mymath{\oplus}, e, x1)
    \emphh{\mymath{\equiv}}
redomap2(\mymath{\oplus}
, fn \mymath{\beta} (\mymath{\beta} e, \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} a2\mymath{\myindx{i}})
   => if c(a1\mymath{\myindx{i}}, a2\mymath{\myindx{i}})
      then \mymath{\oplus}(e, a1\mymath{\myindx{i}}) else e
, e, a1, a2 )

//\emp{redomap2 o filter2\mymath{\Rightarrow}redomap2}
//\emp{{\em{}IFF} consumer's input set}
//\emp{  \mymath{\subseteq} producer's output set}
let (x1,x2)=filter2(c, a1, a2)
in  redomap2(\mymath{\oplus}, g, e, x1)
    \emphh{\mymath{\equiv}}
redomap2(\mymath{\oplus}
, fn \mymath{\beta} (\mymath{\beta} e, \mymath{\alpha\myindx{1}} a1\mymath{\myindx{i}}, \mymath{\alpha\myindx{2}} a2\mymath{\myindx{i}})
   => if c(a1\mymath{\myindx{i}}, a2\mymath{\myindx{i}})
      then g(e, a1\mymath{\myindx{i}}) else e
, e, a1, a2 )
\end{colorcode}
\caption{Compositional Algebra For Fusion}
\label{fig:fusion-algebra}
\end{figure}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis.tex"
%%% End: 
