\chapter{Hindrance removal}
\label{chap:hindrance-removal}

The fusion algorithm presented in previous chapters assumed an input
program with a structure that made any possibilities for fusion as
explicit as possible.  The most obvious such structure is the
normalised input program and the use of tupleless SOACs, but there are
other transformations we can do in order to enable more possibilities
for fusion.

In particular, recall that the fusion algorithm is very strict about
never duplicating computation, and hence multiple uses of the output
of a SOAC may easily block any fusion of the SOAC.  We call such a use
a \textit{hindrance}, with an example shown on
\cref{fig:size-hindrance}(\subref{fig:size-hindrance-blocking}).  In
some cases, the hindrances are unavoidable, but in other cases, a
pre-fusion transformation of the program can remove some unnecessary
hindrances.

\begin{figure}
\begin{subfigure}[t]{.5\textwidth}
\begin{colorcode}
let \emp{b} = map(f, a) in
size(0,\emp{b}) + reduce(op +, 0, \emp{b})
\end{colorcode}
\label{fig:size-hindrance-blocking}
\subcaption{Hindrance blocking fusion}
\end{subfigure}%
\begin{subfigure}[t]{.5\textwidth}
\begin{colorcode}
let \emp{b} = map(f, a) in
size(0,a) + reduce(op +, 0, \emp{b})
\end{colorcode}
\label{fig:size-hindrance-removed}
\subcaption{Hindrance removed}
\end{subfigure}%
\caption{Typical case of \texttt{size}-hindrance}
\label{fig:size-hindrance}
\end{figure}

\Cref{sec:size-hindrance-removal} will cover cases where we can
rewrite \texttt{size}-expressions that reference a SOAC output.
\Cref{sec:inlining-indexing} will describe inlining of index
expressions where the index array is the result of a \texttt{map}
operation.  This inlining may duplicate a small amount of computation.

An important detail is that neither of the presented transformations
should be considered optimisations \textit{per se}.  Rather, their
purpose is enable the fusion optimisation to apply more often.

Both transformations are run completely independently (and in advance)
of fusion.  This results in greater conceptual and technical
simplicity, but at some cost in precision.  In particular, the
rewriting of \texttt{size}-expressions can in fact inhibit fusion in
some cases.

\section{Size Hindrance Removal}
\label{sec:size-hindrance-removal}

Consider the program shown on \cref{fig:size-hindrance}.  The output
of the \texttt{map} producer, \texttt{b}, is used in two places - as
input to a consumer \texttt{reduce}, and as argument to a
\texttt{size} expression.  This means that fusing the two SOACs would
duplicate computation, as we be unable to remove the original
\texttt{map} expression.

Fortunately, in this case, we can exploit a property of \texttt{map}
to rewrite the \texttt{size} expression.  Specifically, the outer size
of the array output from a \texttt{map} expression is equal to the
outer size of its array inputs.  In the context of
\cref{fig:size-hindrance}, this means that the expression
\texttt{size(0,b)} will always give the same value as
\texttt{size(0,a)}.  Hence, we can rewrite the program as shown on
\cref{fig:size-hindrance}(\subref{fig:size-hindrance-removed}), which
has now become fusible.

At first glance, removing \texttt{size} hindrances may appear to
rarely be useful, but in fact, it is crucial to making the fusion
algorithm perform well in practice.  The reason is that the assertions
described in \cref{sec:assertions} check the dimensions of various
arrays via \texttt{size} expressions.  Hence, after the transformation
from external to internal \LO{}, we will have generated several
\texttt{size} expressions, many of which may act as hindrances to
fusion.  As an example, consider this simple program:

\begin{colorcode}
fun [int] main([int] a, [int] b) =
  let \emp{a2} = map(op+(1), a) in
  let \emphh{b2} = map(op+(2), b) in
  map(op+, zip(\emp{a2}, \emphh{b2}))
\end{colorcode}

After transformation to internal \LO{}, we obtain the following
(slightly denormalised for readability):

\begin{colorcode}
fun [int] main([int] a, [int] b) =
  let \{\emp{a2}\} = mapT(op + (1), a) in
  let \{\emphh{b2}\} = mapT(op + (2), b) in
  let a2_sz = size(0, \emp{a2}) in
  let b2_sz = size(0, \emphh{b2})) in
  let zip_assert = assert(a2_sz = b2_sz) in
  let \{res\} = <zip_assert>mapT(op + \emp{a2}, \emphh{b2}) in
  res
\end{colorcode}

Two \texttt{size}-hindrances are present.  Since \texttt{a2} and
\texttt{b2} are the outputs of mapping over \texttt{a} and \texttt{b}
respectively, we can rewrite \texttt{size(0,a2)} to \texttt{size(0,a)}
and \texttt{size(0,b2)} to \texttt{size(0,b)}, thus removing the
nuisances and turning the program fusible.

Our chosen approach is quite simple: Traverse the program, and
whenever an expression of the form \texttt{size($k$,$v$)} is
encountered, see if it can be rewritten to a ``better'' form.  In most
cases, we will have several alternative expressions to choose from,
and hence we need a way to determine the best replacement.

For our purposes, we will want the expression that has the least
chance of being a hindrance to fusion.  As noted in the introduction
to this chapter, hindrance removal is done outside of the fusion
module, and hence we do not have access to precise information about
whether a candidate replacement expression removes a potential
hindrance, or perhaps even moves it.
\Cref{sec:accidentally-adding-hindrances} will describe cases in which
moving \texttt{size}-expressions may cause new hindrances to appear.

It is conceptually simple to generate alternatives to the expression
\texttt{size($k$,$v$)}.  During traversal of the program, we track the
binding of all array-typed variables in a symbol table mapping
variable names to static size information.  For example, after seeing
the binding \texttt{let~a~=~iota($e$)}, we know that
\texttt{size(0,a)} can be rewritten to \texttt{$e$}.  The details of
size analysis are described in \cref{sec:size-analysis}.  However, in
some cases there may be several possible replacement expressions, and
we need a way to select the best one.

We define a heuristic determining the \textit{quality} of a candidate
expression $e$ as follows: For every free variable $v_{i}$ in $e$,
determine the data-flow path from $v_{i}$ to either a constant or a
function parameter.  The quality of the expression is inversely
proportional to the number of nodes in this path, exluding nodes that
are simply copies or indexing.  That is, the expression with the
lowest number is best.  The idea behind this heuristic is to choose
the expression that we can move the furthest up the program, ideally
preceding all SOACs.

For example, for the program shown on
\cref{fig:multiple-replacements}, the hindrance \texttt{size(0, c)}
can be replaced with either \texttt{size(0, b)} or \texttt{size(0,
  a)}.  We pick the latter, because its single free variable can be
traced directly to a function parameter (\texttt{a}), whereas the free
variable in the former can only reach a function parameter through the
binding for \texttt{b}.

\begin{figure}
\begin{center}
\begin{bcolorcode}
fun [int] main([int] a) =
  let b = map(op + (1), a) in
  let c = map(op + (2), b) in
  let n = size(0, c) in
  let d = map(op + (n), d) in
  d
\end{bcolorcode}
\end{center}
\caption{Multiple potential hindrance replacements}
\label{fig:multiple-replacements}
\end{figure}

In the \LO{} compiler, size hindrance removal is implemented as part
of the Rebinder introduced in \cref{sec:rebinder}.  Array sizes are
tracked by inspecting bindings during the traversal of the syntax tree
(as described in the next section).  Whenever we encounter a binding
of a \texttt{size}-expression, we use the size information to obtain
candidate replacements, then use the quality heuristic to determine
the best replacement.

\subsection{Size analysis}
\label{sec:size-analysis}

\begin{description}
\item[\texttt{let $a$ = iota($e$)}] \hfill\\
  $a \mapsto [\{e\}]$

\item[\texttt{let $a$ = replicate($e_{n}$, $e_{v}$)}] \hfill\\
  We know that the number of rows in $a$ is $e_{n}$, but we also know
  that the size of dimension $d$ of $a$ will be the size of dimension
  $d+1$ in $e_{v}$.  This is reflected in the size binding:

  $a \mapsto [\{e_{n}\}, \{size(0,e_{v})\}, \ldots,
  \{size(n,e_{v})\}]$, where $n$ is the rank of $e_{v}$.

\item[\texttt{let \{$a$,$b$\} = split($e_{n}$, $e_{v}$)}] \hfill\\
  The semantics of \texttt{split($e_{n}$, $e_{v}$)} is that the first
  returned array contains the initial $e_{n}$ elements, while the
  remaining \texttt{size(0,$e_{v}$)-$e_{n}$} are in the the second
  returned array.  This leads to the following size bindings:

  $a \mapsto [\{e_{n}\}, \{size(1,e_{v})\}, \ldots, \{size(n,e_{v})]$\\
  $b \mapsto [\{size(0,e_{v})-e_{n}, e_{n}\}, \{size(1,e_{v})\},
  \ldots, \{size(n,e_{v})]$\\
  Where $n$ is the rank of $e_{v}$.

\item[\texttt{let $a$ = concat($e_{x}$, $e_{y}$)}] \hfill\\
  $a \mapsto [\{size(0,e_{x})+size(0,e_{y})\}, \{size(1,e_{x}), size(1,e_{y})\},
  \ldots, \{size(n,e_{x}), size(n,e_{y})]$, where $n$ is the rank of $e_{x}$ and
  $e_{y}$ (the same, according to the type rules of \LO{}).

\item[\texttt{let $a$ = $b$[$e_{0},\ldots,e_{n}$]}] \hfill\\
  $a \mapsto [\{size(n+1,b)\}, \ldots, \{size(m,b)\}]$, where $m$ is
  the rank of $b$.

\item[\texttt{let $a$ = transpose($e$)}] \hfill\\
  $a \mapsto [\{size(1,e)\}, \{size(0,e)\}, \{size(2,e)\}, \ldots,
  \{size(n,b)\}]$, where $n$ is the rank of $b$.

\item[\texttt{let $a$ = $b$ with [\ldots] <- $e$}] \hfill\\
  $a \mapsto [\{size(0,b)\}, \ldots, \{size(n,b)\}]$, where $n$ is the
  rank of $b$.

\item[\texttt{let $\overline{os}$ = mapT(fn $t$ ($p_{1},\ldots,p_{n}$) => $e$, $e_{1}$, \ldots, $e_{n}$)}] \hfill\\
  Within the body of the SOAC function ($e$), the symbol table will
  map the parameters to slices of their corresponding arrays:

  $p_{1} \mapsto [\{size(1, e_{1})\}, \ldots, \{size(m, e_{1})\}]$, where $m$ is the rank of $e_{1}$. \\
  $\vdots$\\
  $p_{n} \mapsto [\{size(1, e_{n})\}, \ldots, \{size(m, e_{n})\}]$, where $m$ is the rank of $e_{n}$. \\
\end{description}

\subsection{Accidentally Adding Hindrances}
\label{sec:accidentally-adding-hindrances}

\begin{colorcode}
let b = map(f, a) in
let c = map\(\myindu{2}\)(g, b) in
let k = size(1,c) in
h(k,c)
\end{colorcode}

\begin{colorcode}
let b = map(f, a) in
let k = size(1,b) in
let c = map\(\myindu{2}\)(g, b) in
h(k,c)
\end{colorcode}

\subsection{Size Hindrance Removal as a Hoisting Enabler}

\section{Inlining of indexing}
\label{sec:inlining-indexing}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
